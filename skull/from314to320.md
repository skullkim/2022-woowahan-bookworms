# 모던 자바 인 액션 P275~P285
## 컬렉션 팩토리
여러 소수의 문자열을 한번에 저장하려면 add메서드를 사용하는 것보단 Arrays.asList 팩토리 메서드를 사용하는 것이 더 간결하다. 
하지만 이 방식으로 만들어진 리스트는 고정 크기라 요소를 갱신할 수는 있지만 새 요소를 추가하거나 삭제할 수 없다.   
요소를 추가하거나 삭제한다면 UnsupportedOperationException이 발생한다.   
이는 asList 메서드가 내부적으로 고정된 크기의 변환할 수 있는 배열로 구현되었기 때문이다.

  Set의 경우 다음과 같이 깔끔하지 못하고 내부적으로 불필요한 객체 할당을 하는 연산을 해야 생성할 수 있다.
```java
Set<String> friends = new HashSet<>(Arrays.asList("a", "b", "c"));
 
Set<String> friends = Stream.of("a", "b", "c")
    .collect(Collectors.toSet());
```
자바 9에서는 위 예시와는 다르게 좀 더 편한 방법으로 컬랙션을 만드는 방법을 제공한다.

### 리스트 팩토리
 List.of 팩토리 메서드를 이용해 리스트를 생성할 수 있다. 하지만 이를 통해 리스트를 만들고 해당 리스트에 요소를 추가한다면 UnsupportedOperationException이 발생한다. 
이는 변경할 수 없는 리스트가 생성됬기 때문이다. 이런 제약은 컬렉션이 의도치 않게 변하는 것을 막을 수 있다. 또 한 이 방식은 nulll 요소를 금지하기에 의도치 않은 버그를 방지한다.

  List.of 메서드를 보면 0~10 개의 파라미터 까지는 오버로드 되있고 11개 이상은 가변 인수로 받는다. 이런 구현을 한 이유는 최적화를 위해서다. 
가변 인수를 사용하면 추가 배열을 할당해 리스트로 감싸기 떄문에 배열을 할당하고 초기화하며 나중에 GC 비용을 지불해야 한다. Set.of 와 Map.of 메서드 역시 같은 방식을 사용한다.
```java
List<Integer> numbers = List.of(1, 2, 3);
```
### 집합 팩토리
Set.of를 사용하면 집합을 만들 수 있다. 만약 메서드 인자로 넘긴 값 중 중복된 값이 있다면 IllegalArgumentException이 발생한다.
```java
Set<String> firends = Set.of("a", "b", "c");
```
### 맵 팩토리
  자바 9에서는 Map.of와 Map.Entry<K, V> 두 방식을 통해 바꿀 수 없는 맵을 초기화할 수 있다.

  Map.of의 경우 10개 이하의 키와 값 쌍을 가진 맵을 만들 때 유용하다.
```java
// 인자엔 키와 값이 번갈아 등장한다
Map<String, Integer> ageOfFriends = Map.of("a", 30, "b", 26);
```
 11개 이상의 쌍을 가진다면 Map.ofEntries 팩토리 메서드를 이용하는 것이 좋다. 이 메서드는 키, 값을 감쌀 추가 객체를 필요로 한다. 
Map.entry는 Map.Entry 객체를 만드는 새로운 팩토리 메서드다.
```java
import static java.util.Map.entry;
Map<String, Integer> ageOfFriends = Map.ofEntries(entry("a", 30),
        entry("b", 34),
        entry("c", 35));
```
## 리스트와 집합 처리
  자바 8은 List, Set 인터페이스에다음과 같은 컬렉션 자체를 바꾸는 메서드를 추가했다.

    removeIf: 프리디케이트를 만족하는 요소를 제거한다.

    replaceAll: 리스트에서 이용할 수 있는 기능으로 UnaryOperator 함수를 이용해 요소를 바꾼다.

    sort: List 인터페이스에서 제공하는 기능으로 리스트를 정렬한다.

  이런 컬렉션 자체를 바꾸는 메서드가 추가된 이유는 컬렉션 자체를 바꾸는 동작이 에러를 유발하고 복잡하기 때문이다.
### removeIf 메서드
  다음과 같은 코드가 있다 해보자.
```java
for (Transaction transaction : transactions) {
    if (Character.isDigit(transaction.getReferenceCode().charAt(0))) {
        transactions.remove(transaction);
    }
}
```
  for-each 루프는 내부적으로 Iterator 객체를 사용하므로 다음과 같이 해석할 수 있다.
```java
// Iterator 객체와
for (Iteratro<Transaction> iterator = transactions.iterator(); iteratro.hasNext();) {
    // Transaction 객체를 통해 컬렉션을 관리한다.
    Transaction transaction = iterator.next();
    if (Character.isDigit(transaction.getReferenceCode().charAt(0))) {
        transactions.remove(transaction);
    }
}

```
 위 코드에서 볼 수 있듯이. for-each는 내부적으로 두 개의 개별 객체가 컬랙션을 관리한다. 따라서 반복자의 상태는 컬랙션의 상태와 서로 동기화 되지 않는다. 
따라서 ConcurrentModificationException이 발생한다. 이 문제를 해결하려면 Iterator 객체를 명시적으로 사용하고 그 객체의 remove 메서드를 호출해야 한다.
```java
for (Iterator<Transaction> iterator = transactions.iterator(); iterator.hasNext()) {
    Transaction transaction = iterator.next();
    if (Character.isDigit(transaction.getReferenceCode().charAt(0))) {
        transactions.remove(transaction);
    }
}

```
 하지만 코드가 복잡하다. 자바 8의 removeIf 메서드를 사용하면 다음과 같이 간결화 할 수 있다.
```java
transactions.removeIf(transaction -> 
    Character.isDigit(transaction.getReferenceCode().charAt(0)));
```
### replaceAll 메서드
  replaceAll 메서드를 사용하면 리스트의 각 요소를 바꿀 수 있다. 
```java
referenceCodes.replaceAll(code -> Character.toUpperCase(code.charAt(0)) + code.substring(1));
```
## 맵 처리
### forEach 메서드
  자바 8부터 Map 인터페이스는 key, value를 인자로 받는 BiConsumer를 인수로 받는 forEach 메서드를 지원한다. 따라서 Map을 다음과 같이 순회할 수 있다.
```java
ageOfFriends.forEach((firend, age) ->
    System.out.println(friend + " is" + age + " years old"));
```
### 정렬 메서드
 다음 유틸리티를 사용하면 맵의 항목을 값 또는 키를 기준으로 정렬할 수 있다.

    - Entry.comparingByValue

    - Entry.comparingByKey
```java
favouriteMovies.entrySet()
    .stream()
    .sorted(Entry.comparingByKey())
    .forEachOrdered(System.out::println);
 
```
### HashMap 성능
  자바 8에서 HashMap의 내부 구조를 바꿔 성능을 개선했다. 기존에 맵의 항목은 키로 생성한 해시코드로 접근할 수 있는 버킷에 저장했다. 
따라서 많은 키가 같은 해시코드를 반환하게 되면 O(n)의 시간이 걸리는 LinkedList로 버킷을 반환해야 하므로 성능이 저사된다. 
자바 8부터는 버킷이 커지면 O(logn)의 시간이 소요되는 정렬된 트리를 이용해 종적으로 치환해 충돌이 일어나는 요소 반환 성능을 개선했다. 
하지만 String, Integer 처럼 Comparable의 형태여야만 정렬된 트리가 지원된다.

### getOrDefault 메서드
 기존 방식으로는 키가 존재하지 않으면 null이 반환되 null 체크를 해야했다. 이는 getOrDefault 메서드로 해결할 수 있다. 
getOrDefault 메서드는 첫 번째 인자로 키를, 두 번째 인자로 기본값을 받는다. 만약 첫 번째 인자로 넘긴 키가 없다면 두 번째 인자로 넘긴 기본값을 반환한다. 
하지만 키가 존재해도 값이 널이라면 기본값을 반환하지 않는다. 
```java
Map<String, String> favouriteMovies = Map.ofEntries(entry("a", "b"));
favouriteMovies.getOrDefautl("a", "c");
```